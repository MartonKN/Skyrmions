#include<GPE_dataStructures.h>
#include<GPE_IO.h>
#include<GPE_spline.h>
#include<GPE_monitoring.h>
#include<GPE_random.h>

int create_filenames(char filenameFilenames[],char filenameSystemParameters[],
		     char filenameBaseOrderParameters[]) {
	// The MATLAB routune that initializes the system gives back a file (filenameFilenames), that
	// contains the names of all the other necessary files for the GPE algorithm. 
	// These are the other ones in the argument list of this function.
	FILE *fp;
	char *tmpP;
	int j;
	fp=fopen(filenameFilenames,"r");
	if(fp==NULL) {
		cerr<<"Couldn't open file "<<filenameFilenames<<"."<<endl;
		return 0;
	}
	fscanf(fp,"%s",filenameSystemParameters);
	fclose(fp);
	tmpP=strstr(filenameSystemParameters,"SystemParameters");
	char tmpStr[tmpP-filenameSystemParameters];
	for(j=0;j<tmpP-filenameSystemParameters;j++) {
		tmpStr[j]=filenameSystemParameters[j];
	};
	tmpStr[tmpP-filenameSystemParameters]='\0';
	strcpy(filenameBaseOrderParameters,tmpStr);
	strcat(filenameBaseOrderParameters,"OrderParameters");
	return 1;
};

int load_SystemParameters(char filenameSystemParameters[],System_Parameters& sysparams) {
	// Loads the text file 'filenameSystemParameters', that had been generated by a MATLAB routine.
	FILE *fp;
	char valueOfParameterString[100];
	char tmpStr[100];
	int j,k;
	int returnValue=1;
	fp=fopen(filenameSystemParameters,"r");
	
	returnValue=
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::Mx",&sysparams.Mx)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::My",&sysparams.My)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::Mz",&sysparams.Mz)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::ax",&sysparams.ax)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::ay",&sysparams.ay)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::az",&sysparams.az)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::tmax",&sysparams.tmax)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::dt",&sysparams.dt)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::T",&sysparams.T)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::V0",&sysparams.V0)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::V2",&sysparams.V2)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::J",&sysparams.J)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::mu_0",&sysparams.mu_0)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::trapx",&sysparams.trapx)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::trapy",&sysparams.trapy)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::trapz",&sysparams.trapz)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::Nmax",&sysparams.Nmax)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::AbsPsi_Max",&sysparams.AbsPsi_Max)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::AbsPsi_Steps",&sysparams.AbsPsi_Steps)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::AbsF_Steps",&sysparams.AbsF_Steps)*
	loadParameterDouble(fp,filenameSystemParameters,"SystemParameters::SqrtMinusDmu_Max",&sysparams.SqrtMinusDmu_Max)*
	loadParameterInt   (fp,filenameSystemParameters,"SystemParameters::SqrtMinusDmu_Steps",&sysparams.SqrtMinusDmu_Steps);
	sysparams.M=sysparams.Mx*sysparams.My*sysparams.Mz;
	sysparams.D_AbsPsi=sysparams.AbsPsi_Max/(sysparams.AbsPsi_Steps-1.0);
	sysparams.D_AbsF=1.0/(sysparams.AbsF_Steps-1.0);
	sysparams.D_SqrtMinusDmu=sysparams.SqrtMinusDmu_Max/(sysparams.SqrtMinusDmu_Steps-1.0);
	if(sysparams.V0!=1.0) {
		cerr<<"Interaction V0 is not 1."<<endl;
		cerr<<"All system parameters of energy dimension are being rescaled by 1/V0."<<endl;
		double rescale=1.0/sysparams.V0;
		sysparams.T*=rescale;
		sysparams.V0*=rescale; sysparams.V2*=rescale;
		sysparams.J*=rescale;
		sysparams.mu_0*=rescale;
		sysparams.trapx*=rescale; sysparams.trapy*=rescale; sysparams.trapz*=rescale;
		sysparams.SqrtMinusDmu_Max*=sqrt(rescale);
		sysparams.D_SqrtMinusDmu*=sqrt(rescale);
	}
	
	// saving times
	sysparams.length_saving_times_array=0;
	do{
		sprintf(tmpStr,"SystemParameters::saving_times[%d]",sysparams.length_saving_times_array);
		sysparams.length_saving_times_array++;
	}while(findParameterInFile(fp,tmpStr,valueOfParameterString));
	sysparams.length_saving_times_array--;
	if(sysparams.length_saving_times_array==0) {
		cerr<<"Could not load sysparams.saving_times in function load_SystemParameters()."<<endl;
		returnValue=0;
	}
	else {
		sysparams.saving_times=new double[sysparams.length_saving_times_array];
		for(j=0;j<sysparams.length_saving_times_array;j++) {
			sprintf(tmpStr,"SystemParameters::saving_times[%d]",j);
			findParameterInFile(fp,tmpStr,valueOfParameterString);
			sysparams.saving_times[j]=atof(valueOfParameterString);
		};
	}
	
	if(!findParameterInFile(fp,"SystemParameters::dispform_saving_times[0]",valueOfParameterString)) {
		cerr<<"Could not read variable dispform_saving_times[0] from file "<<filenameSystemParameters<<"."<<endl;
		returnValue=0;
	}
	sysparams.dispform_saving_times[0]=atoi(valueOfParameterString);
	if(!findParameterInFile(fp,"SystemParameters::dispform_saving_times[1]",valueOfParameterString)) {
		cerr<<"Could not read variable dispform_saving_times[1] from file "<<filenameSystemParameters<<"."<<endl;
		returnValue;
	}
	sysparams.dispform_saving_times[1]=atoi(valueOfParameterString);
	
	// noise parameters
	sysparams.length_addNoiseTimes_array=0;
	do{
		sprintf(tmpStr,"SystemParameters::addNoiseTimes[%d]",sysparams.length_addNoiseTimes_array);
		sysparams.length_addNoiseTimes_array++;
	}while(findParameterInFile(fp,tmpStr,valueOfParameterString));
	sysparams.length_addNoiseTimes_array--;
	if(sysparams.length_addNoiseTimes_array==0) {
		cerr<<"Could not load sysparams.addNoiseTimes in function load_SystemParameters()."<<endl;
		returnValue=0;
	}
	else {
		sysparams.addNoiseTimes=new double[sysparams.length_addNoiseTimes_array];
		sysparams.noOfFreqs=new int[sysparams.length_addNoiseTimes_array];
		sysparams.randomnessRate=new double * [sysparams.length_addNoiseTimes_array];
		sysparams.maxFreqRate=new double * [sysparams.length_addNoiseTimes_array];
		for(j=0;j<sysparams.length_addNoiseTimes_array;j++) {
			sysparams.maxFreqRate[j]=new double[3];
			sysparams.randomnessRate[j]=new double[3];
		};
		for(j=0;j<sysparams.length_addNoiseTimes_array;j++) {
			sprintf(tmpStr,"SystemParameters::addNoiseTimes[%d]",j);
			findParameterInFile(fp,tmpStr,valueOfParameterString);
			sysparams.addNoiseTimes[j]=atof(valueOfParameterString);
		};
		for(j=0;j<sysparams.length_addNoiseTimes_array;j++) {
			sprintf(tmpStr,"SystemParameters::noOfFreqs[%d]",j);
			findParameterInFile(fp,tmpStr,valueOfParameterString);
			sysparams.noOfFreqs[j]=atoi(valueOfParameterString);
		};
		for(j=0;j<sysparams.length_addNoiseTimes_array;j++) {
			for(k=0;k<3;k++){
				sprintf(tmpStr,"SystemParameters::maxFreqRate[%d][%d]",j,k);
				findParameterInFile(fp,tmpStr,valueOfParameterString);
				sysparams.maxFreqRate[j][k]=atof(valueOfParameterString);
			};
		};
		for(j=0;j<sysparams.length_addNoiseTimes_array;j++) {
			for(k=0;k<3;k++){
				sprintf(tmpStr,"SystemParameters::randomnessRate[%d][%d]",j,k);
				findParameterInFile(fp,tmpStr,valueOfParameterString);
				sysparams.randomnessRate[j][k]=atof(valueOfParameterString);
			};
		};
	}
	
	if(!findParameterInFile(fp,"SystemParameters::nthreads",valueOfParameterString)) {
		cerr<<"Could not read variable nthreads from file "<<filenameSystemParameters<<"."<<endl;
		returnValue;
	}
	if(!strcmp(valueOfParameterString,"USE_MAX_NUM_PROCS")) {
		sysparams.nthreads=USE_MAX_NUM_PROCS;
	}
	else {
		sysparams.nthreads=(int)(atof(valueOfParameterString));
	}
	fclose(fp);
	
	// Set GPE_ran seed.
	sysparams.idum=-13514;
	
	return returnValue;
}

int loadParameterDouble(FILE* fp,char filenameSystemParameters[],char nameOfParameter[],double* parameterPtr) {
	char valueOfParameterString[100];
	if(!findParameterInFile(fp,nameOfParameter,valueOfParameterString)) {
		cerr<<"Could not read variable "<<nameOfParameter<<" from file "<<filenameSystemParameters<<"."<<endl;
		return 0;
	}
	*parameterPtr=atof(valueOfParameterString);
	return 1;
}

int loadParameterInt(FILE* fp,char filenameSystemParameters[],char nameOfParameter[],int* parameterPtr) {
	char valueOfParameterString[100];
	if(!findParameterInFile(fp,nameOfParameter,valueOfParameterString)) {
		cerr<<"Could not read variable "<<nameOfParameter<<" from file "<<filenameSystemParameters<<"."<<endl;
		return 0;
	}
	*parameterPtr=atoi(valueOfParameterString);
	return 1;
}

int findParameterInFile(FILE* fp,char nameOfParameter[],char valueOfParameterString[]) {
	// Finds the variable 'nameOfParameter' between the characters '=' and ',' in file 'fp'.
	// The variable's value is put into 'valueOfParameterString' in string form.
	char *tmpString=NULL;
	size_t len=0;
	ssize_t read;
	// Array containing the whole content of the file
	char *fileString;
	int lengthFileString;
	fseek(fp,0,SEEK_END);
	lengthFileString=ftell(fp);
	fileString=new char[lengthFileString+1];
	// Variables for finding the number that we're looking for
	char startVarString[2]="=",endVarString[2]=",";
	char *cp,*cpStart,*cpEnd;
	int j;
	// Return value
	int returnValue;
	
	rewind(fp);
	strcpy(fileString,"");
	while((read=getline(&tmpString,&len,fp))!=-1){
		strcat(fileString,tmpString);
	}
	free(tmpString);
	cp=strstr(fileString,nameOfParameter);
	if(cp==NULL) {
		returnValue=0;
	}
	else {
		cpStart=strstr(cp,startVarString);
		cpEnd=strstr(cpStart,endVarString);
		char parameterStringTmp[cpEnd-cpStart];
		for(j=0;j<(cpEnd-cpStart-1);j++) {
			parameterStringTmp[j]=cpStart[j+1];
		};
		parameterStringTmp[cpEnd-cpStart-1]='\0';
		j=0; while(parameterStringTmp[j]==' ') {j++;}
		strcpy(valueOfParameterString,parameterStringTmp+j);
		returnValue=1;
	}
	
	delete[] fileString;
	return returnValue;
}

void initializePsisAndGPE(GPE_Parameters& gpe,System_Parameters sysparams,GPE_Psis &Psis) {
	register int ix,iy,iz,j;
	double x,y,z;
	double MASS_x,MASS_y,MASS_z;
	register double expx[sysparams.Mx],expy[sysparams.My],expz[sysparams.Mz];
	register double AbsPsi,SqrtMinusDmu;
	double tmp;
	MASS_x=6.0*6.0*sysparams.J*sysparams.T/(2.0*sysparams.ax*sysparams.ax);
	MASS_y=6.0*6.0*sysparams.J*sysparams.T/(2.0*sysparams.ay*sysparams.ay);
	MASS_z=6.0*6.0*sysparams.J*sysparams.T/(2.0*sysparams.az*sysparams.az);
	
	// Set time to zero
	gpe.t=0.0;
	// Fill gpe.EXP
	// Note: since the fftw transformation doesn't take care about normalization
	// of the Fourier-transformed Psis, we include here the normalization: 1/sysparams.M.
	for(ix=0;ix<sysparams.Mx/2;ix++) {
		tmp=(PI*ix/((sysparams.Mx-1.0)*sysparams.ax));
		expx[ix]=exp(-sysparams.dt/MASS_x*tmp*tmp)/sysparams.Mx;
	};
	for(ix=sysparams.Mx/2;ix<sysparams.Mx;ix++) {
		tmp=(PI*(ix-sysparams.Mx)/((sysparams.Mx-1.0)*sysparams.ax));
		expx[ix]=exp(-sysparams.dt/MASS_x*tmp*tmp)/sysparams.Mx;
	};
	for(iy=0;iy<sysparams.My/2;iy++) {
		tmp=(PI*iy/((sysparams.My-1.0)*sysparams.ay));
		expy[iy]=exp(-sysparams.dt/MASS_y*tmp*tmp)/sysparams.My;
	};
	for(iy=sysparams.My/2;iy<sysparams.My;iy++) {
		tmp=(PI*(iy-sysparams.My)/((sysparams.My-1.0)*sysparams.ay));
		expy[iy]=exp(-sysparams.dt/MASS_y*tmp*tmp)/sysparams.My;
	};
	for(iz=0;iz<sysparams.Mz/2;iz++) {
		tmp=(PI*iz/((sysparams.Mz-1.0)*sysparams.az));
		expz[iz]=exp(-sysparams.dt/MASS_z*tmp*tmp)/sysparams.Mz;
	};
	for(iz=sysparams.Mz/2;iz<sysparams.Mz;iz++) {
		tmp=(PI*(iz-sysparams.Mz)/((sysparams.Mz-1.0)*sysparams.az));
		expz[iz]=exp(-sysparams.dt/MASS_z*tmp*tmp)/sysparams.Mz;
	};
	for(ix=0;ix<sysparams.Mx;ix++) {
		for(iy=0;iy<sysparams.My;iy++) {
			for(iz=0;iz<sysparams.Mz;iz++) {
				gpe.EXP[iz+sysparams.Mz*(iy+sysparams.My*ix)]=expx[ix]*expy[iy]*expz[iz];
			};
		};
	};
	// Find LDA values of AbsPsi with AbsF set to zero
	double SeffMin;
	int j_SqrtMinusDmu;
	for(ix=0;ix<sysparams.Mx;ix++) {
		for(iy=0;iy<sysparams.My;iy++) {
			for(iz=0;iz<sysparams.Mz;iz++) {
				SqrtMinusDmu=sqrt(sysparams.trapx*(ix-0.5*(sysparams.Mx-1.0))*(ix-0.5*(sysparams.Mx-1.0))
				                 +sysparams.trapy*(iy-0.5*(sysparams.My-1.0))*(iy-0.5*(sysparams.My-1.0))
				                 +sysparams.trapz*(iz-0.5*(sysparams.Mz-1.0))*(iz-0.5*(sysparams.Mz-1.0)));
				j_SqrtMinusDmu=floor(SqrtMinusDmu/sysparams.D_SqrtMinusDmu);
				x=ix-0.5*(sysparams.Mx-1.0);
				y=iy-0.5*(sysparams.My-1.0);
				z=iz-0.5*(sysparams.Mz-1.0);
				tmp=1.0/sqrt(x*x+y*y+z*z);
				x*=tmp; y*=tmp; z*=tmp;
				
				// Find the LDA value for AbsPsi
				for(AbsPsi=0.0,SeffMin=1e20,j=0;j<sysparams.AbsPsi_Steps;j++) {
					if(gpe.SeffLDA[j_SqrtMinusDmu][j][0]<SeffMin) {
						SeffMin=gpe.SeffLDA[j_SqrtMinusDmu][j][0];
						AbsPsi=j*sysparams.D_AbsPsi;
					}
				};
				// Imprint the hedgehog
				Psis.Psi1[iz+sysparams.Mz*(iy+sysparams.My*ix)][0]=AbsPsi*x;
				Psis.Psi1[iz+sysparams.Mz*(iy+sysparams.My*ix)][1]=0.0;
				Psis.Psi2[iz+sysparams.Mz*(iy+sysparams.My*ix)][0]=AbsPsi*y;
				Psis.Psi2[iz+sysparams.Mz*(iy+sysparams.My*ix)][1]=0.0;
				Psis.Psi3[iz+sysparams.Mz*(iy+sysparams.My*ix)][0]=AbsPsi*z;
				Psis.Psi3[iz+sysparams.Mz*(iy+sysparams.My*ix)][1]=0.0;
				Psis.PsiI1[j][0]=Psis.Psi1[j][0];
				Psis.PsiI1[j][1]=Psis.Psi1[j][1];
				Psis.PsiI2[j][0]=Psis.Psi2[j][0];
				Psis.PsiI2[j][1]=Psis.Psi2[j][1];
				Psis.PsiI3[j][0]=Psis.Psi3[j][0];
				Psis.PsiI3[j][1]=Psis.Psi3[j][1];
				Psis.PsiK1[j][0]=Psis.Psi1[j][0];
				Psis.PsiK1[j][1]=Psis.Psi1[j][1];
				Psis.PsiK2[j][0]=Psis.Psi2[j][0];
				Psis.PsiK2[j][1]=Psis.Psi2[j][1];
				Psis.PsiK3[j][0]=Psis.Psi3[j][0];
				Psis.PsiK3[j][1]=Psis.Psi3[j][1];
			};
		};
	};
}

int load_initial_GPE_Psis(char filenameInitialConditions[],GPE_Psis& Psis,System_Parameters sysparams) {
	// Loads the initial values of the GPE, that has been formerly generated by a MATLAB routine.
	// The order parameters (Psi1,Psi2 and Psi3) are stored in the data file 'filenameInitialConditions'
	// as a string of 'double' numbers. 
	// The data is ordered as: RePsi1[1...sysparams.M], ImPsi1[1...sysparams.M], 
	//                         RePsi2[1...sysparams.M], ImPsi2[1...sysparams.M].
	//                         RePsi3[1...sysparams.M], ImPsi3[1...sysparams.M].
	register int j;
	double tmpArray[sysparams.M];
	FILE *fp=fopen(filenameInitialConditions,"r");
	if(fp==NULL){
		cerr<<"Couldn't open file "<<filenameInitialConditions<<endl;
		return 0;
	}
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi1[j][0]=tmpArray[j];
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi1[j][1]=tmpArray[j];
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi2[j][0]=tmpArray[j];
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi2[j][1]=tmpArray[j];
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi3[j][0]=tmpArray[j];
	fread(tmpArray,sizeof(double)*sysparams.M,1,fp);
	for(j=0;j<sysparams.M;j++)
		Psis.Psi3[j][1]=tmpArray[j];
	fclose(fp);
	
	return 1;
}

int save_Psis(const char filename[],GPE_Psis Psis,GPE_Parameters gpe,System_Parameters sysparams,FFTW_Struct FFTW_Variables) {
	// Saving method: put the real and imaginary parts of the order parameters and densities
	// in a consecutive manner: [RePsi1,ImPsi1,RePsi2,ImPsi2,RePsi3,ImPsi3,
	//                           Re_n11,Re_n12,Im_n12,Re_n13,Im_n13,Re_n22,Re_n23,Im_n23,Re_n33,
	//                           Re_nTOF11,Re_nTOF12,Im_nTOF12,Re_nTOF13,Im_nTOF13,Re_nTOF22,Re_nTOF23,Im_nTOF23,Re_nTOF33,
	//                           RePhiAverage1,ImPhiAverage1,RePhiAverage2,ImPhiAverage2,RePhiAverage3,ImPhiAverage3].
	// The reason for this strange solution is that MATLAB can read data in a consecutive manner.
	// Note: throughout the saving prcess we use the arrays  Psis.PsiI1, Psis.PsiI2, Psis.PsiI3,
	// Psis.PsiK1, Psis.PsiK2 and Psis.PsiK3 to store temporary arrays of data. 
	// Since Psis.PsiI-s and Psis.PsiK-s are used only in the GPE iterations as auxiliary arrays one can do this safely.
	int jmax=sysparams.length_saving_times_array;
	register int j,k1,k2,k3;
	register int MyMz=sysparams.My*sysparams.Mz,MxMyMz=sysparams.Mx*MyMz;
	char filename_thisfile[150];
	char time_str[20];
	char format_str[8]="__%3.3f";
	char tmp_ch[1];
	FILE *fp;
	register double out_data [MyMz];
	register double SqrtMinusDmu;
	register dcomplex PsiVec[3];
	register cmatrix tmpMx(3,3);
	for(j=0;j<jmax;j++) {
		if(sysparams.saving_times[j]>=gpe.t-0.5*sysparams.dt && 
		   sysparams.saving_times[j]< gpe.t+0.5*sysparams.dt) {
			sprintf(tmp_ch,"%d",sysparams.dispform_saving_times[0]);
			format_str[3]=tmp_ch[0];
			sprintf(tmp_ch,"%d",sysparams.dispform_saving_times[1]);
			format_str[5]=tmp_ch[0];
			sprintf(time_str,format_str,gpe.t);
			strcpy(filename_thisfile,filename);
			strcat(filename_thisfile,time_str);
			fp=fopen(filename_thisfile,"w");
			if(fp==NULL) {
				cerr<<endl<<"Error opening file >> "<<filename_thisfile<<" << in function save_Psis()."<<endl;
				return 0;
			};
			
			// RePsi1
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// ImPsi1
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi1[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// RePsi2
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// ImPsi2
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi2[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// RePsi3
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi3[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// ImPsi3
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.Psi3[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			// n
			#if SAVE_DENSITIES
			for(j=0,k1=0;k1<sysparams.Mx;k1++){
				for(k2=0;k2<sysparams.My;k2++) {
					for(k3=0;k3<sysparams.Mz;k3++,j++) {
						SqrtMinusDmu=sqrt(sysparams.trapx*(k1-0.5*(sysparams.Mx-1.0))*(k1-0.5*(sysparams.Mx-1.0))
						                 +sysparams.trapy*(k2-0.5*(sysparams.My-1.0))*(k2-0.5*(sysparams.My-1.0))
						                 +sysparams.trapz*(k3-0.5*(sysparams.Mz-1.0))*(k3-0.5*(sysparams.Mz-1.0)));
						PsiVec[0]=Psis.Psi1[j];
						PsiVec[1]=Psis.Psi2[j];
						PsiVec[2]=Psis.Psi3[j];
						tmpMx=evaluateSplineDensities(SqrtMinusDmu,PsiVec,gpe,sysparams);
						// We use the auxiliary arrays Psis.PsiI1, Psis.PsiI2, Psis.PsiI3
						// and Psis.PsiK1, Psis.PsiK2, Psis.PsiK3
						// to temporarily store the results.
						// The order of saving the densities is n11.re, n12.re, n12.im,
						// n13.re, n13.im, n22.re, n23.re, n23.im, n33.
						Psis.PsiI1[j][0]=tmpMx[0][0].re;
						Psis.PsiI1[j][1]=tmpMx[0][1].re;
						Psis.PsiI2[j][0]=tmpMx[0][1].im;
						Psis.PsiI2[j][1]=tmpMx[0][2].re;
						Psis.PsiI3[j][0]=tmpMx[0][2].im;
						Psis.PsiI3[j][1]=tmpMx[1][1].re;
						Psis.PsiK1[j][0]=tmpMx[1][2].re;
						Psis.PsiK1[j][1]=tmpMx[1][2].im;
						Psis.PsiK2[j][0]=tmpMx[2][2].re;
					};
				};
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI1[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK1[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			#else
			for(k1=0,k2=0;k1<9*sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=0.0;
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			#endif
			
			// Density correlations for TOF measurements
			densityCorrelations(Psis.PsiI1,Psis.PsiI2,Psis.PsiI3,Psis.PsiK1,Psis.PsiK2,Psis.PsiK3,Psis,gpe,sysparams,FFTW_Variables);
			// We put the data for the density correlations into Psis.PsiI1, Psis.PsiI2 etc.
			// These arrays are used only during iterations of the GPE and don't store any useful information
			// outside of the GPE functions.
			//n_11(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//n_12(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//n_13(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//n_22(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//n_23(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK2[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//n_33(k)
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiK3[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			
			// Expectation values of the annihilation operators
			phiAvereages(Psis.PsiI1,Psis.PsiI2,Psis.PsiI3,Psis,gpe,sysparams);
			// We put these data into Psis.PsiI1, Psis.PsiI2 etc. These arrays are used only 
			// during iterations of the GPE and don't store any useful information outside of 
			// the GPE functions.
			//RePhiAverage1
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI1[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//ImPhiAverage1
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI1[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//RePhiAverage2
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//ImPhiAverage2
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI2[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//RePhiAverage3
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][0];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			//ImPhiAverage3
			for(k1=0,k2=0;k1<sysparams.Mx;k1++) {
				for(k3=0;k3<MyMz;k2++,k3++)
					out_data[k3]=Psis.PsiI3[k2][1];
				fwrite(out_data,sizeof(double)*MyMz,1,fp);
			};
			
			fclose(fp);
			break;
		}
	};
	return 1;
};

void reset_dt(GPE_Parameters gpe,System_Parameters& sysparams,GPE_Psis Psis,FFTW_Struct FFTW_Variables) {
	// dt = 0.02* |\Sum dS/dPsi_i * Psi_i^*| / \Sum |Psi_i|^2
	double normPsi1,normPsi2,normPsi3;
	double kinEnergy1,kinEnergy2,kinEnergy3;
	double tmp1,tmp2,tmp3;
	dcomplex tmp_dcomplex;
	register int jloc,jx,jy,jz;
	register double SqrtMinusDmu;
	register dcomplex PsiVec[3];
	
	// Norms
	norms(&normPsi1,&normPsi2,&normPsi3,Psis,sysparams);
	
	// |\Sum dS/dPsi_i * Psi_i^*| kinetic energy part
	kineticEnergy(&kinEnergy1,&kinEnergy2,&kinEnergy3,Psis,sysparams,FFTW_Variables);
	
	// |\Sum dS/d(Psi_i^*) * Psi_i^*| potential energy part
	for(jx=0,tmp1=0.0,tmp2=0.0,tmp3=0.0;jx<sysparams.Mx;jx++){
		for(jy=0;jy<sysparams.My;jy++) {
			for(jz=0;jz<sysparams.Mz;jz++){
				jloc=jz+sysparams.Mz*(jy+sysparams.My*jx);
				SqrtMinusDmu=sqrt(sysparams.trapx*(jx-0.5*(sysparams.Mx-1.0))*(jx-0.5*(sysparams.Mx-1.0))
				                 +sysparams.trapy*(jy-0.5*(sysparams.My-1.0))*(jy-0.5*(sysparams.My-1.0))
				                 +sysparams.trapz*(jz-0.5*(sysparams.Mz-1.0))*(jz-0.5*(sysparams.Mz-1.0)));
				PsiVec[0]=Psis.Psi1[jloc];
				PsiVec[1]=Psis.Psi2[jloc];
				PsiVec[2]=Psis.Psi3[jloc];
				tmp_dcomplex=evaluateSpline(1,SqrtMinusDmu,PsiVec,gpe,sysparams);
				tmp1+=tmp_dcomplex.re*Psis.Psi1[jloc][0]+tmp_dcomplex.im*Psis.Psi1[jloc][1];
				tmp_dcomplex=evaluateSpline(2,SqrtMinusDmu,PsiVec,gpe,sysparams);
				tmp2+=tmp_dcomplex.re*Psis.Psi2[jloc][0]+tmp_dcomplex.im*Psis.Psi2[jloc][1];
				tmp_dcomplex=evaluateSpline(3,SqrtMinusDmu,PsiVec,gpe,sysparams);
				tmp3+=tmp_dcomplex.re*Psis.Psi3[jloc][0]+tmp_dcomplex.im*Psis.Psi3[jloc][1];
			};
		};
	};
	
	if(normPsi1!=0.0 && normPsi2!=0.0 && normPsi3!=0.0) {
		sysparams.dt=__min(0.0005,0.02*__min(__min((fabs(tmp1)+kinEnergy1)/normPsi1,(fabs(tmp2)+kinEnergy2)/normPsi2),
						     (fabs(tmp3)+kinEnergy3)/normPsi3));
	}
	else {
		cerr<<"Problem in function reset_dt()."<<endl;
		cerr<<"\t"<<"sysparams.dt could not be reset because the initial conditions are identically 0!"<<endl<<endl;
	}
	printf("sysparams.dt=%6.15f\n",sysparams.dt);
}

void saveSystemParameters(char filenameSystemParameters[],System_Parameters sysparams) {
	FILE *fp;
	int i,j;
	char tmpStr[200];
	
	fp=fopen(filenameSystemParameters,"w");
	fprintf(fp,"Grid size:\n");
	fprintf(fp,"SystemParameters::Mx=%d,\n",sysparams.Mx);
	fprintf(fp,"SystemParameters::My=%d,\n",sysparams.My);
	fprintf(fp,"SystemParameters::Mz=%d,\n",sysparams.Mz);
	fprintf(fp,"\n");
	fprintf(fp,"SystemParameters::ax=%3.10f,\n",sysparams.ax);
	fprintf(fp,"SystemParameters::ay=%3.10f,\n",sysparams.ay);
	fprintf(fp,"SystemParameters::az=%3.10f,\n",sysparams.az);
	fprintf(fp,"\n");
	fprintf(fp,"Maximal imaginary time and imaginary time step of the GPE simulation\n");
	fprintf(fp,"SystemParameters::tmax=%3.10f,\n",sysparams.tmax);
	fprintf(fp,"SystemParameters::dt=%3.10f,\n",sysparams.dt);
	fprintf(fp,"\n");
	fprintf(fp,"Physical parameters (energy measured in units of V0=(V11+V22)/2):\n");
	fprintf(fp,"SystemParameters::T=%3.10f,\n",sysparams.T);
	fprintf(fp,"SystemParameters::J=%3.10f,\n",sysparams.J);
	fprintf(fp,"SystemParameters::mu_0=%3.10f,\n",sysparams.mu_0);
	fprintf(fp,"SystemParameters::V0=%3.10f,\n",sysparams.V0);
	fprintf(fp,"SystemParameters::V2=%3.10f,\n",sysparams.V2);
	fprintf(fp,"SystemParameters::trapx=%3.10f,\n",sysparams.trapx);
	fprintf(fp,"SystemParameters::trapy=%3.10f,\n",sysparams.trapy);
	fprintf(fp,"SystemParameters::trapz=%3.10f,\n",sysparams.trapz);
	fprintf(fp,"\n");
	fprintf(fp,"Parameters for the splines:\n");
	fprintf(fp,"SystemParameters::Nmax=%d,\n",sysparams.Nmax);
	fprintf(fp,"SystemParameters::AbsPsi_Max=%3.10f,\n",sysparams.AbsPsi_Max);
	fprintf(fp,"SystemParameters::SqrtMinusDmu_Max=%3.10f,\n",sysparams.SqrtMinusDmu_Max);
	fprintf(fp,"SystemParameters::AbsPsi_Steps=%d,\n",sysparams.AbsPsi_Steps);
	fprintf(fp,"SystemParameters::AbsF_Steps=%d,\n",sysparams.AbsF_Steps);
	fprintf(fp,"SystemParameters::SqrtMinusDmu_Steps=%d,\n",sysparams.SqrtMinusDmu_Steps);
	fprintf(fp,"SystemParameters::D_AbsPsi=%3.10f,\n",sysparams.D_AbsPsi);
	fprintf(fp,"SystemParameters::D_AbsF=%3.10f,\n",sysparams.D_AbsF);
	fprintf(fp,"SystemParameters::D_SqrtMinusDmu=%3.10f,\n",sysparams.D_SqrtMinusDmu);
	fprintf(fp,"\n");
	fprintf(fp,"Random noise parameters:\n");
	for(i=0;i<sysparams.length_addNoiseTimes_array;i++) {
		fprintf(fp,"SystemParameters::addNoiseTimes[%d]=%3.10f,\n",i,sysparams.addNoiseTimes[i]);
	};
	for(i=0;i<sysparams.length_addNoiseTimes_array;i++) {
		fprintf(fp,"SystemParameters::noOfFreqs[%d]=%d,\n",i,sysparams.noOfFreqs[i]);
	};
	for(i=0;i<sysparams.length_addNoiseTimes_array;i++) {
		for(j=0;j<3;j++) {
			fprintf(fp,"SystemParameters::maxFreqRate[%d][%d]=%3.10f,\t",i,j,sysparams.maxFreqRate[i][j]);
		};
		fprintf(fp,"\n");
	};
	for(i=0;i<sysparams.length_addNoiseTimes_array;i++) {
		for(j=0;j<3;j++) {
			fprintf(fp,"SystemParameters::randomnessRate[%d][%d]=%3.10f,\t",i,j,sysparams.randomnessRate[i][j]);
		};
		fprintf(fp,"\n");
	};
	fprintf(fp,"\n");
	fprintf(fp,"Saving times:\n");
	for(i=0;i<sysparams.length_saving_times_array;i++)
		fprintf(fp,"SystemParameters::saving_times[%d]=%3.10f,\n",i,sysparams.saving_times[i]);
	fprintf(fp,"\n");
	fprintf(fp,"This variable encodes how the saving times appear in the filenames:\n");
	fprintf(fp,"SystemParameters::dispform_saving_times[0]= %d,\n",sysparams.dispform_saving_times[0]);
	fprintf(fp,"SystemParameters::dispform_saving_times[1]= %d,\n",sysparams.dispform_saving_times[1]);
	fprintf(fp,"\n");
	fprintf(fp,"Number of processors to be used:\n");
	fprintf(fp,"SystemParameters::nthreads=%d,\n",sysparams.nthreads);
	fclose(fp);
}

void addRandomNoise(GPE_Psis Psis,GPE_Parameters gpe,System_Parameters sysparams) {
	int j,jmax=sysparams.length_addNoiseTimes_array;
	for(j=0;j<jmax;j++) {
		if(sysparams.addNoiseTimes[j]>=gpe.t-0.5*sysparams.dt && 
		   sysparams.addNoiseTimes[j]< gpe.t+0.5*sysparams.dt) {
			noise(Psis,sysparams.noOfFreqs[j],sysparams.maxFreqRate[j],sysparams.randomnessRate[j],sysparams);
			break;
		}
	};
}

void noise(GPE_Psis Psis,int noOfFreqs,double *maxFreqRate,double *randomnessRate,System_Parameters sysparams) {
	// Adds a random noise to Psis.Psi1,Psis.Psi2 and Psis.Psi3. 
	// Since Psis.PsiKk and Psis.PsiIk (k=1,2,3) are auxiliary variables, they don't have to be modified here.
	// The iteration cycle of the GPE solver routine uses only the values of Psis.Psik as inputs.
	// Algorithm:
	// Psis.Psik += amplitude*exp(i*(freqx*jx+freqy*jy+freqz*jz))
	// noOfFreqs: the number of times this random part will be added at randomly chosen quasimomenta (freqx,freqy,freqz).
	// maxFreqRate[3]: the random frequencies will come from an interval width endpoints at 
	//                 +-maxFreqRate[k]*(the maximal possible quasimomentum)
	// randomnessRate: amplitude=randomnessRate[k]*|Psis.Psik|_2
	
	register int i,j,jx,jy,jz,k;
	register dcomplex amplitude[noOfFreqs],exponential;
	register double freqx,freqy,freqz;
	double NPsi[3]={0.0,0.0,0.0};
	register fftw_complex *whichPsi;
	double norm_amplitude;
	register int threadID;
	
	for(j=0;j<sysparams.M;j++) {
		NPsi[0]+=sqr_norm(Psis.Psi1[j]);
		NPsi[1]+=sqr_norm(Psis.Psi2[j]);
		NPsi[2]+=sqr_norm(Psis.Psi3[j]);
	};
	NPsi[0]=sqrt(NPsi[0]/sysparams.M);
	NPsi[1]=sqrt(NPsi[1]/sysparams.M);
	NPsi[2]=sqrt(NPsi[2]/sysparams.M);
	
	for(k=0;k<3;k++) {
		for(i=0,norm_amplitude=0.0;i<noOfFreqs;i++) {
			amplitude[i].re=GPE_ran(&sysparams.idum); 
			amplitude[i].im=GPE_ran(&sysparams.idum);
			norm_amplitude+=amplitude[i].re*amplitude[i].re+amplitude[i].im*amplitude[i].im;
		};
		norm_amplitude=sqrt(norm_amplitude);
		for(i=0;i<noOfFreqs;i++) {
			freqx=2.0*PI*floor(maxFreqRate[0]*sysparams.Mx*GPE_ran(&sysparams.idum))/(sysparams.Mx-1.0);
			freqy=2.0*PI*floor(maxFreqRate[1]*sysparams.My*GPE_ran(&sysparams.idum))/(sysparams.My-1.0);
			freqz=2.0*PI*floor(maxFreqRate[2]*sysparams.Mz*GPE_ran(&sysparams.idum))/(sysparams.Mz-1.0);
			if(norm_amplitude!=0.0) {
				amplitude[i].re*=randomnessRate[k]/norm_amplitude*NPsi[k]; 
				amplitude[i].im*=randomnessRate[k]/norm_amplitude*NPsi[k];
			}
			else
				amplitude[i]=0.0;
			switch(k) {
			  case 0:
				whichPsi=Psis.Psi1;
				break;
			  case 1:
				whichPsi=Psis.Psi2;
				break;
			  case 2:
				whichPsi=Psis.Psi3;
				break;
			}
			#pragma omp parallel private(threadID) 
			{
				threadID=omp_get_thread_num();
				cpu_set_t new_mask;
				cpu_set_t was_mask;
				CPU_ZERO(&new_mask);		// Makes the new_mask CPU set empty
				CPU_SET(threadID,&new_mask);	// Orders new_mask to threadID
				if (sched_getaffinity(0,sizeof(was_mask),&was_mask) == -1) {
					cerr<<"Error: sched_getaffinity("<<threadID<<", sizeof(was_mask), &was_mask)"<<endl;
				}
				if (sched_setaffinity(0, sizeof(new_mask), &new_mask) == -1) {
					cerr<<"Error: sched_setaffinity("<<threadID<<", sizeof(was_mask), &was_mask)"<<endl;
				}
				#pragma omp for schedule(dynamic) nowait private(jx,jy,jz,j,exponential)
				for(jx=0;jx<sysparams.Mx;jx++){
					for(jy=0;jy<sysparams.My;jy++) {
						for(jz=0;jz<sysparams.Mz;jz++) {
							j=jz+sysparams.Mz*(jy+sysparams.My*jx);
							exponential.re=cos(freqx*jx+freqy*jy+freqz*jz);
							exponential.im=sin(freqx*jx+freqy*jy+freqz*jz);
							whichPsi[j][0]+=amplitude[i].re*exponential.re-amplitude[i].im*exponential.im;
							whichPsi[j][1]+=amplitude[i].re*exponential.im+amplitude[i].im*exponential.re;
						};
					};
				};
			}
		};
	};
	for(j=0;j<sysparams.M;j++){
		Psis.PsiI1[j][0]=Psis.Psi1[j][0];
		Psis.PsiI1[j][1]=Psis.Psi1[j][1];
		Psis.PsiK1[j][0]=Psis.Psi1[j][0];
		Psis.PsiK1[j][1]=Psis.Psi1[j][1];
		Psis.PsiI2[j][0]=Psis.Psi2[j][0];
		Psis.PsiI2[j][1]=Psis.Psi2[j][1];
		Psis.PsiK2[j][0]=Psis.Psi2[j][0];
		Psis.PsiK2[j][1]=Psis.Psi2[j][1];
		Psis.PsiI3[j][0]=Psis.Psi3[j][0];
		Psis.PsiI3[j][1]=Psis.Psi3[j][1];
		Psis.PsiK3[j][0]=Psis.Psi3[j][0];
		Psis.PsiK3[j][1]=Psis.Psi3[j][1];
	};
}